Author: aszlig <aszlig@nix.build>
Date:   Tue Mar 27 05:37:27 2018 +0200

    Always allow to change the group leader
    
    We have free group plans anyway, so it really doesn't make much sense to
    prevent a group leader to hand over leadership to another person.
    
    For the official instance something like this would make sense, because
    the other person didn't necessarily pay or is able to pay for the group
    plan, but on our instance the group plan is free.
    
    Signed-off-by: aszlig <aszlig@nix.build>
    Filename: always-permit-group-leader-change.patch

diff --git a/website/server/controllers/api-v3/groups.js b/website/server/controllers/api-v3/groups.js
index eed6e42da..b8c7ae4dc 100644
--- a/website/server/controllers/api-v3/groups.js
+++ b/website/server/controllers/api-v3/groups.js
@@ -403,8 +403,6 @@ api.updateGroup = {
     if (group.leader !== user._id && group.type === 'party') throw new NotAuthorized(res.t('messageGroupOnlyLeaderCanUpdate'));
     else if (group.leader !== user._id && !user.contributor.admin) throw new NotAuthorized(res.t('messageGroupOnlyLeaderCanUpdate'));
 
-    if (req.body.leader !== user._id && group.hasNotCancelled()) throw new NotAuthorized(res.t('cannotChangeLeaderWithActiveGroupPlan'));
-
     _.assign(group, _.merge(group.toObject(), Group.sanitizeUpdate(req.body)));
 
     let savedGroup = await group.save();
diff --git a/website/server/models/group.js b/website/server/models/group.js
index e1c044f06..4dd5f3104 100644
--- a/website/server/models/group.js
+++ b/website/server/models/group.js
@@ -18,7 +18,6 @@ import {
 import {
   InternalServerError,
   BadRequest,
-  NotAuthorized,
 } from '../libs/errors';
 import baseModel from '../libs/baseModel';
 import { sendTxn as sendTxnEmail } from '../libs/email';
@@ -1185,14 +1184,6 @@ schema.methods.leave = async function leaveGroup (user, keep = 'keep-all', keepC
   let group = this;
   let update = {};
 
-  if (group.memberCount <= 1 && group.privacy === 'private' && group.hasNotCancelled()) {
-    throw new NotAuthorized(shared.i18n.t('cannotDeleteActiveGroup'));
-  }
-
-  if (group.leader === user._id && group.hasNotCancelled()) {
-    throw new NotAuthorized(shared.i18n.t('leaderCannotLeaveGroupWithActiveGroup'));
-  }
-
   // only remove user from challenges if it's set to leave-challenges
   if (keepChallenges === 'leave-challenges') {
     let challenges = await Challenge.find({
